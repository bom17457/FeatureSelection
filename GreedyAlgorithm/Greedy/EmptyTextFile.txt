using System;
using System.Collections.Generic;
using System.Linq;

namespace Greedy
{
    class MainClass
    {


        class Node
        {
            public int node_index = 0;
            public char node_name;
            public int CharToIndex = 0;
            public double correlation = 0;
            public Node parent_node = null;

            public Node(char node_name, int node_index, double correlation)
            {
                this.node_name = node_name;
                this.node_index = node_index;
                this.CharToIndex = Math.Abs((int)node_name - 65);
                this.correlation = correlation;
            }

            public String toObject()
            {
                return "{index:"+node_index+", inChar:"+node_name+ ", correlation:"+correlation+"}";
            }
        }

        public static void Main(string[] args)
        {
            List<List<Object>> data = getTrainDataList();
            //double[,] data = getTrainDataList
            GreedySearch(data);
        }

        private static List<List<Object>> getTrainDataList()
        {
            List<List<Object>> x = new List<List<object>>();
            for (int i = 0; i < getTrainData().GetLength(0); i++)
            {
                List<Object> jArray = new List<Object>();
                for(int j = 0; j < getTrainData().GetLength(1); j++)
                {
                    jArray.Add(getTrainData()[i, j]);
                }
                x.Add(jArray);
            }
            return x;
        }

        private static List<List<Object>> removeColumnTitle(List<List<Object>> data)
        {
            List<List<Object>> x = new List<List<object>>();
            CopyListTo(data, x);
            x.RemoveAt(0);
            return x;
        }


        private static void CopyListTo(List<List<object>> source, List<List<object>> target)
        {
            for (int i = 0; i < source.Count; i++)
            {
                List<Object> jArray = new List<Object>();
                for (int j = 0; j < source.ElementAt(i).Count; j++)
                {
                    jArray.Add(source.ElementAt(i).ElementAt(j));
                }
                target.Add(jArray);
            }
        }

        private static Object[,] getTrainData()
        {
            Object[,] x = 
            {
                {'A'  ,'B' ,'C' ,'D' ,'E' ,'F' ,'G','H','I','J' ,'K' ,'L','M','N' ,'O' ,'P' ,'Q' ,'R','S','T','U','V','W','X'},
                {0.27,3.72,1.01,5.65,3.29,4.68,1,0.9,1,1.24,0.91,1,1,0.87,0.85,0.88,0.81,1,1,1,1,0.8,1,208},
                { 1.02,4.96,1.01,5.65,2.19,4.68,1.0,0.9,1.0,1.24,0.91,1.0,1.0,0.87,0.85,0.88,0.81,1.1,1.0,1.0,1.0,0.8,1.0,195 },
                { 2.52,3.72,1.01,5.65,3.29,4.68,1,0.9,1,1.24,0.91,1,1,0.87,0.85,0.88,0.81,1,1,1,1,0.8,1,162 },
                { 4.02,3.72,3.04,2.83,0,3.12,1.1,1,1,1.07,1.11,1,1,0.87,0.85,0.88,0.81,0.88,0.91,0.91,1,0.8,1,113 },
                { 4.28,4.96,1.01,5.65,3.29,4.68,1,0.9,1.17,1.24,0.91,1,1,0.87,0.85,0.88,0.81,1.1,1,1,1,0.8,1,277 },
                { 4.48,4.96,1.01,5.65,1.1,4.68,1.1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,0.91,0.91,1,0.8,1,175 },
                { 5,4.96,1.01,5.65,1.1,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1,0.91,0.91,1,0.8,1,120 },
                { 5.11,2.48,1.01,5.65,1.1,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,0.88,0.91,0.91,1,0.8,1,189 },
                {5.29,1.24,1.01,5.65,0,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,1.19,1.2,1,0.8,1,417},
                {7.44,4.96,1.01,5.65,1.1,4.68,1,0.9,1.17,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,0.91,0.91,1,0.8,1,302},
                {7.7,4.96,1.01,5.65,0,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,1,0.91,1,0.8,1,567},
                {8.41,4.96,1.01,5.65,1.1,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1,0.91,0.91,1,0.8,1,153},
                {8.8,4.96,1.01,5.65,2.19,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,1.09,1,1,0.8,1,142},
                {9.99,4.96,1.01,5.65,3.29,4.68,1,0.9,1,1.24,0.91,1,1,0.87,0.85,0.88,0.81,1.1,1,1,1,0.8,1,526},
                {25.84,4.96,1.01,5.65,1.1,4.68,1.1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,0.91,0.91,1,0.8,1,202},
                {26.22,4.96,1.01,4.24,1.1,4.68,1,0.9,1,0.95,1,1,1,0.87,0.85,1,0.81,0.81,0.91,0.91,1,0.8,1,175},
                {30.13,3.72,1.01,5.65,2.19,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1,1.09,1,1,0.8,1,206},
                {32.56,4.96,1.01,5.65,2.19,4.68,1,0.9,1,1.24,0.91,1,1,0.87,0.85,0.88,0.81,1.1,0.91,0.91,1,0.8,1,794},
                {36.27,4.96,1.01,5.65,1.1,4.68,1,0.9,1,1.24,0.91,1,1,0.87,0.85,0.88,0.81,1.1,0.91,0.91,1,0.8,1,667},
                {38.85,4.96,1.01,4.24,1.1,4.68,1,0.9,1,0.95,1,1,1,0.87,0.85,1,0.81,0.81,0.85,0.84,1,0.8,1,230},
                {42.81,3.72,3.04,5.65,1.1,4.68,1,0.9,0.87,1,0.91,1,1,0.87,0.85,0.88,0.81,1,1.09,1.09,1,0.8,1,439},
                {42.9,2.48,1.01,5.65,2.19,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,0.88,0.91,0.91,1,0.8,1,361},
                {45.14,2.48,3.04,5.65,1.1,4.68,1,0.9,0.87,1,0.91,1,1,0.87,0.85,0.88,0.81,0.88,1,1,1,0.8,1,486},
                {55.55,4.96,1.01,5.65,1.1,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,0.91,0.91,1,0.8,1,763},
                {57.77,2.48,2.03,1.41,0,3.12,1.1,1,1,1.07,1.11,1.29,1,0.87,0.85,0.88,0.81,0.88,0.91,0.91,1,0.8,1,405},
                {59.14,1.24,1.01,5.65,2.19,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,0.81,0.85,0.84,1,0.8,1,331},
                {62.78,6.2,3.04,4.24,0,3.12,1,1,1,1.07,1.11,1,1,0.87,0.85,0.88,0.81,0.88,0.91,0.91,1,0.8,1,422},
                {67.32,1.24,1.01,5.65,0,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,0.81,0.85,0.84,1,0.8,1,234},
                {79.82,4.96,1.01,5.65,1.1,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1,0.91,0.91,1,0.8,1,636},
                {112.28,4.96,1.01,5.65,1.1,4.68,1,0.9,1,1,0.91,1,1,0.87,0.85,0.88,0.81,1.1,0.91,0.91,1,0.8,1,1278},
    };
            return x;
        }

        private static double[] getColumn(List<List<Object>> data, int column)
        {
            int row = data.Count;
            double[] x = new double[row];
            for (int i = 0; i < row; i++)
            {
                x[i] = Double.Parse((data.ElementAt(i).ElementAt(column).ToString()));

            }
            return x;
        }


        private static double[] getColumn(double[,] data, int column)
        {
            int row = data.GetLength(0);
            double[] x = new double[row];

            for (int i = 0; i < row; i++)
            {
                x[i] = data[i, column];
            }
            return x;
        }

        private static void CreateChild(List<List<Object>>  data,List<List<Object>> compileData, List<Node> child_state, List<Node> best_node)
        {
            List<int> indexArray = new List<int>();
            int column_length = compileData.ElementAt(0).Count -1;

            for(int i=0;i<best_node.Count; i++) {
                indexArray.Add(best_node.ElementAt(i).CharToIndex);
            }

            //Factor Factor
            double[,] r_FactorFactor;
            double compute_Factor_Factor = 0.0f;
            for (int i=0;i<compileData.ElementAt(0).Count; i++)
            {
                indexArray.Add(i);
                r_FactorFactor = getMultiColumn(compileData, indexArray.ToArray());
                compute_Factor_Factor += ComputeFactorFactor(r_FactorFactor);
                indexArray.RemoveAt(indexArray.Count - 1);
            }

            //Factor Effort
            double[,] r_FactorEffort;
            double compute_Factor_Effort = 0.0f;
            for(int i=0;i<compileData.ElementAt(0).Count; i++)
            {
                indexArray.Add(i);
                r_FactorEffort = getMultiColumn(compileData, indexArray.ToArray());
                compute_Factor_Effort += ComputeFactorEffort(r_FactorEffort, getColumn(compileData, column_length));
            }

            double current_correlation = ComputeCorrelationSum(compileData.ElementAt(0).Count, compute_Factor_Effort, compute_Factor_Factor);
            int last_index_Array = indexArray.Count - 1;
            Node correlationNode = new Node(
                Char.Parse(data.ElementAt(0).ElementAt(indexArray.ElementAt(last_index_Array)).ToString()),
                indexArray.Count-1, 
                current_correlation
                );
            child_state.Add(correlationNode);

            /* for (int i = 0; i < defaultData.ElementAt(0).Count - 1; i++)
             {
                 //Factor Factor
                 double[,] r_FactorFactor;
                 double compute_Factor_Factor = 0.0f;
                 for (int j = i+1; j < defaultData.ElementAt(i).Count - 1; j++)
                 {
                     r_FactorFactor = mapArrays(getColumn(compileData, i), getColumn(compileData, j));
                     compute_Factor_Factor += ComputeFactorFactor(r_FactorFactor);
                 }

                 //Factor EFFORT
                 double[,] r_FactorEffort;
                 double compute_Factor_Effort = 0.0f;
                 for (int j =i+1; j< defaultData.ElementAt(i).Count-1; j++)
                 {
                     r_FactorEffort = mapArrays(getColumn(compileData, i), getColumn(compileData, j));
                     compute_Factor_Effort += ComputeFactorEffort(r_FactorEffort, getColumn(compileData, compileData.ElementAt(0).Count - 1));
                 }

                 double current_correlation = ComputeCorrelationSum(compileData.ElementAt(0).Count, compute_Factor_Effort, compute_Factor_Factor);
                 Node correlationNode = new Node(Char.Parse(data.ElementAt(0).ElementAt(i).ToString()), i, current_correlation);
                 child_state.Add(correlationNode);
             }*/
        }

        private static bool deleteColumn(List<List<Object>> data, int column)
        {
            int row = data.Count;
            List<List<Object>> newData = new List<List<Object>>();
            for (int i=0;i<row; i++)
            {
                if(data.ElementAt(0).Count != 0)
                {
                    data.ElementAt(i).RemoveAt(column);
                }
                else
                {
                    return false;
                }
            }

            return true;
        }

        private static List<Node> GreedySearch(List<List<Object>> data)
        {
            List<Node> best_node = new List<Node>();
            List<List<Object>> compileData = new List<List<Object>>();

            double initial_state = 0;
            double goal_state = 1;
            double current_state = 0;

            if (initial_state.Equals(goal_state))
            {
                return best_node;
            }
            else
            {
                current_state = initial_state;
                int layer = 0;
                while (!goal_state.Equals(current_state))
                {
                    Console.WriteLine("\nLayer:" + layer++);

                    //best_index is index of column                    
                    List<Node> child_state = new List<Node>();

                    //createChild 
                    CreateChild(data, removeColumnTitle(data), child_state, best_node);

                    //show client node
                    foreach (Node node in child_state)
                    {
                        Console.WriteLine(node.toObject());
                    }

                    //find best Correlation
                    Node CurrentCorrelation = new Node('A',0,0.0f);
                    for(int i = 0; i < child_state.Count; i++)
                    {
                        if((child_state.ElementAt(i).correlation > CurrentCorrelation.correlation))
                        {
                            CurrentCorrelation = child_state[i];
                        }else if (i.Equals(0))
                        {
                            CurrentCorrelation = child_state[i];
                        }
                    }
                    Console.WriteLine("Best Factor in This Node : " + CurrentCorrelation.toObject());
                    //ถ้า function deleteColumn เป็น false แสดงว่าทำจนหมดทั้ง column
                    if (!deleteColumn(data, CurrentCorrelation.node_index))
                    {
                        current_state = 1.0f;
                    }
                    else
                    {
                        //if has the data in best_node Any(); return true
                        if (best_node.Any())
                        {
                            Console.WriteLine(best_node.ElementAt(Math.Abs(best_node.Count - 1)).correlation < CurrentCorrelation.correlation);
                            if (best_node.ElementAt(Math.Abs(best_node.Count - 1)).correlation < CurrentCorrelation.correlation)
                            {
                                best_node.Add(CurrentCorrelation);
                                Console.WriteLine("Best Node: " + CurrentCorrelation.toObject());                               
                            }
                        }
                        else
                        {
                            best_node.Add(CurrentCorrelation);
                            Console.WriteLine("Best Node: "+ CurrentCorrelation.toObject());
                        }
                    }
                }

                Console.WriteLine("RESULT FACTOR : ");
                foreach (Node node in best_node)
                {
                    Console.WriteLine(node.toObject());
                }
            }

            return best_node;
        }

        private static double[,] getMultiColumn(double[,] data, int[] index)
        {
            int rowLen = data.GetLength(0);
            int colLen = index.Length;
            double[,] combineData = new double[rowLen, colLen];
            for (int i = 0; i < rowLen; i++)
            {
                for (int j = 0; j < colLen; j++)
                {
                    combineData[i, j] = data[i, index[j]];
                }
            }
            return combineData; //return ค่าเป็นข้อมูลหลาย Columns
        }

        private static double[,] getMultiColumn(List<List<Object>> data, int[] index)
        {
            int rowLen = data.Count;
            int colLen = index.Length;
            double[,] combineData = new double[rowLen, colLen];
            for (int i = 0; i < rowLen; i++)
            {
                for (int j = 0; j < colLen; j++)
                {
                    combineData[i, j] = Double.Parse(data.ElementAt(i).ElementAt(index[j]-1).ToString());
                }
            }
            return combineData; //return ค่าเป็นข้อมูลหลาย Columns
        }

        private static bool IsDuplicate(double[] x, double[] y)
        {
            double[] ax = x;
            double[] ay = y;
            Array.Sort(ax);
            Array.Sort(ay);
            return Enumerable.SequenceEqual(ax, ay);
        }
         
        private static double ComputeCorrelationSum(int m, double Factor_Effort, double Factor_Factor)
        {
            if (Factor_Factor.Equals(-1))
            {
                return Factor_Effort;
            }

            double r_correlation = (m * Factor_Effort) / (Math.Sqrt(m + (m * (m - 1) * Factor_Factor)));
            return Double.IsNaN(r_correlation)||Double.IsInfinity(r_correlation)?0:r_correlation;
        }

        //สำหรับคำนวณ ค่าความสัมพันธ์ระหว่างปัจจัยในชุด s ทั้งหมด กับ Effort
        private static double ComputeFactorEffort(double[,] x, double[] Effort)
        {
            double r_sum = 0;
            int x_length = x.GetLength(1);
            double[] Factor;
            for (int i = 0; i < x_length; i++)
            {
                Factor = getColumn(x, i);
                //double r = Math.Abs(Correlation(Factor, Effort));
                double r = Correlation(Factor, Effort);
                if (Double.IsNaN(r) || Double.IsInfinity(r)) r = 0;
                r_sum = r_sum + r;
            }
            return r_sum / x_length;
        }



        private static double ComputeFactorFactor(double[,] x)
        {
            double r_sum = 0;
            int count = 0;
            int x_length = x.GetLength(1);

            //if (x_length == 1) return 1; // ถ้ามี 1 ปัจจัยให้ return 1 โดยที่ 1 มาจากความสัมพันธ์ระหว่างตัวมันเอง
            for (int i = 0; i < x_length - 1; i++)
            {
                for (int j = 1; j < x_length; j++)
                {
                    //double r = Math.Abs(Correlation(getColumn(x, i), getColumn(x, j)));
                    double r = Correlation(getColumn(x, i), getColumn(x, j));
                    if (Double.IsNaN(r) || Double.IsInfinity(r)) r = 0;
                    r_sum = r_sum + r;
                    count++;
                }
            }
            return r_sum / count;
        }

        private static double Correlation(IEnumerable<Double> xs, IEnumerable<Double> ys)
        {
            // sums of x, y, x squared etc.
            double sx = 0.0;
            double sy = 0.0;
            double sxx = 0.0;
            double syy = 0.0;
            double sxy = 0.0;

            int n = 0;

            using (var enX = xs.GetEnumerator())
            {
                using (var enY = ys.GetEnumerator())
                {
                    while (enX.MoveNext() && enY.MoveNext())
                    {
                        double x = enX.Current;
                        double y = enY.Current;

                        n += 1;
                        sx += x;
                        sy += y;
                        sxx += x * x;
                        syy += y * y;
                        sxy += x * y;
                    }
                }
            }

            // covariation
            double cov = sxy / n - sx * sy / n / n;
            // standard error of x
            double sigmaX = Math.Sqrt(sxx / n - sx * sx / n / n);
            // standard error of y
            double sigmaY = Math.Sqrt(syy / n - sy * sy / n / n);

            // correlation is just a normalized covariation
            return cov / sigmaX / sigmaY;
        }

    }
}